/**
 * Auth Service
 * Handles login, session management, and password security
 */
import { v4 as uuidv4 } from 'uuid';
import * as UserRepository from '../users/user.repository.js';
import * as SessionRepository from './session.repository.js';
import { Session } from '../../../../types/index.js';
import { AuthUser, LoginResponse } from './auth.types.js';
import { hashPassword, verifyPassword } from '../../shared/utils/password.js';

const SESSION_DURATION_SECONDS = 30 * 60; // 30 minutes
const DUMMY_HASH = '$2b$10$InCX8UtTmhbQP3NuHPaRAeCdfZeaIngIzsAjWjbAYxjprs6WHcoAG';

function buildAuthUser(userId: number): AuthUser {
  const user = UserRepository.findUserById(userId);
  if (!user || user.is_active === 0 || user.deleted_at) {
    throw new Error('User not found or inactive');
  }

  const permissions = UserRepository.getUserPermissions(userId);
  const roles = UserRepository.getUserRoles(userId).map(r => r.name);

  return {
    id: user.id,
    name: user.name,
    username: user.username,
    roles,
    permissions
  };
}

function createSession(user: AuthUser): string {
    const token = uuidv4();
    const expiresAt = Math.floor(Date.now() / 1000) + SESSION_DURATION_SECONDS;

    const session: Session = {
        id: '', // Will be generated by repository
        user_id: user.id,
        token,
        expires_at: expiresAt,
        name: user.name,
        username: user.username,
        roles: user.roles,
        permissions: user.permissions
    };

    SessionRepository.create(session);
    return token;
}

export function getSession(token: string): AuthUser | null {
    if (!token) return null;

    const now = Math.floor(Date.now() / 1000);

    // Clean up expired sessions periodically (every 100th call to reduce overhead)
    if (Math.random() < 0.01) {
        SessionRepository.deleteExpired(now);
    }

    const session = SessionRepository.findByToken(token);
    if (!session) return null;

    // Verify user still exists and is active
    const currentUser = UserRepository.findUserById(session.user_id);
    if (!currentUser || currentUser.is_active === 0 || currentUser.deleted_at) {
        SessionRepository.deleteByToken(token);
        return null;
    }

    // Check expiration
    if (session.expires_at < now) {
        SessionRepository.deleteByToken(token);
        return null;
    }

    const permissions = UserRepository.getUserPermissions(session.user_id);
    const roles = UserRepository.getUserRoles(session.user_id).map(r => r.name);

    const newExpiresAt = now + SESSION_DURATION_SECONDS;
    SessionRepository.updateExpiration(token, newExpiresAt);

    return {
        id: currentUser.id,
        name: currentUser.name,
        username: currentUser.username,
        roles,
        permissions
    };
}

export function endSession(token: string): void {
    SessionRepository.deleteByToken(token);
}

export async function login(username: string, password: string): Promise<LoginResponse> {
    const user = UserRepository.findUserByUsername(username);
    const userPasswordHash = (user && user.is_active !== 0 && !user.deleted_at) ? (user.password_hash || '') : DUMMY_HASH;
    const isValid = await verifyPassword(password, userPasswordHash);

    if (!user || user.is_active === 0 || user.deleted_at || !isValid) {
        throw new Error('Invalid username or password');
    }

    const userData = buildAuthUser(user.id);
    const token = createSession(userData);

    return { user: userData, token };
}

export async function me(userId: number): Promise<AuthUser> {
    return buildAuthUser(userId);
}

export function clearAllSessions(): void {
    SessionRepository.deleteAll();
}

export function revokeUserSessions(userId: number): void {
    SessionRepository.deleteByUserId(userId);
}
